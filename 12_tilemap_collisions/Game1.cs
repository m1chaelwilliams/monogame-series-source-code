// `Data` contains the CSVs for the project
// `Sprite.cs` is the Sprite class referenced in this file
// A good portion of this code is automatically generated by the
// MonoGame template; don't be deterred!

using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace ytgame;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    private Dictionary<Vector2, int> mg;
    private Dictionary<Vector2, int> fg;
    private Dictionary<Vector2, int> collisions;
    private Texture2D textureAtlas;
    private Texture2D hitboxTexture;
    private Vector2 camera;

    private int TILESIZE = 64; // size of the tiles in our game
    private Texture2D rectangleTexture;

    // sprite

    private Sprite player;
    private List<Rectangle> intersections;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = "Content";
        IsMouseVisible = true;
        fg = LoadMap("../../../Data/level1_fg.csv");
        mg = LoadMap("../../../Data/level1_mg.csv");
        collisions = LoadMap("../../../Data/level1_collisions.csv");
        camera = Vector2.Zero;
        intersections = new();
    }

    // Opens a CSV file, reads it line by line, splits the line into
    // an array of integers. Converts data into a Dictionary where the
    // keys is the physical position of the number in the file
    // (e.g. line 3, column 2) => (2, 1)).
    private Dictionary<Vector2, int> LoadMap(string filepath) {
        Dictionary<Vector2, int> result = new();

        StreamReader reader = new(filepath);

        int y = 0;
        string line;
        while ((line = reader.ReadLine()) != null) {

            string[] items = line.Split(',');

            for (int x = 0; x < items.Length; x++) {
                if (int.TryParse(items[x], out int value)) {
                    if (value > -1) {
                        result[new Vector2(x, y)] = value;
                    }
                }
            }

            y++;

        }

        return result;
    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here
        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        textureAtlas = Content.Load<Texture2D>("tempassets");
        hitboxTexture = Content.Load<Texture2D>("hitboxes");

        rectangleTexture = new Texture2D(GraphicsDevice, 1, 1);
        rectangleTexture.SetData(new Color[] {new (255, 0, 0, 255)});

        player = new Sprite(
            Content.Load<Texture2D>("player_static"),
            new Rectangle(TILESIZE, TILESIZE, TILESIZE, TILESIZE*2),
            new Rectangle(0,0,8,16)
        );
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();        
       
        player.Update(Keyboard.GetState());

        // add player's velocity and grab the intersecting tiles
        player.rect.X += (int)player.velocity.X;
        intersections = getIntersectingTilesHorizontal(player.rect);

        foreach (var rect in intersections) {

            // handle collisions if the tile position exists in the tile map layer.
            if (collisions.TryGetValue(new Vector2(rect.X, rect.Y), out int _val)) {
                
                // create temp rect to handle collisions (not necessary, you can optimize!)
                Rectangle collision = new(
                    rect.X * TILESIZE,
                    rect.Y * TILESIZE,
                    TILESIZE,
                    TILESIZE
                );

                // handle collisions based on the direction the player is moving
                if (player.velocity.X > 0.0f) {
                    player.rect.X = collision.Left - player.rect.Width;
                } else if (player.velocity.X < 0.0f) {
                    player.rect.X = collision.Right;
                }

            }

        }

        // same as horizontal collisions

        player.rect.Y += (int)player.velocity.Y;
        intersections = getIntersectingTilesVertical(player.rect);

        foreach (var rect in intersections) {

            if (collisions.TryGetValue(new Vector2(rect.X, rect.Y), out int _val)) {

                Rectangle collision = new Rectangle(
                    rect.X * TILESIZE,
                    rect.Y * TILESIZE,
                    TILESIZE,
                    TILESIZE
                );

                if (player.velocity.Y > 0.0f) {
                    player.rect.Y = collision.Top - player.rect.Height;
                } else if (player.velocity.Y < 0.0f) {
                    player.rect.Y = collision.Bottom;
                }
                
            }
        }

        base.Update(gameTime);
    }

    // grabs the intersecting tiles for a Rect. This grabs all tile positions where
    // an intersection is __possible__, not if a tile actually exists there.
    public List<Rectangle> getIntersectingTilesHorizontal(Rectangle target) {

        List<Rectangle> intersections = new();

        int widthInTiles = (target.Width - (target.Width % TILESIZE)) / TILESIZE;
        int heightInTiles = (target.Height - (target.Height % TILESIZE)) / TILESIZE;

        for (int x = 0; x <= widthInTiles; x++) {
            for (int y = 0; y <= heightInTiles; y++) {

                intersections.Add(new Rectangle(

                    (target.X + x*TILESIZE) / TILESIZE,
                    (target.Y + y*(TILESIZE-1)) / TILESIZE,
                    TILESIZE,
                    TILESIZE

                ));

            }
        }

        return intersections;
    }
    public List<Rectangle> getIntersectingTilesVertical(Rectangle target) {

        List<Rectangle> intersections = new();

        int widthInTiles = (target.Width - (target.Width % TILESIZE)) / TILESIZE;
        int heightInTiles = (target.Height - (target.Height % TILESIZE)) / TILESIZE;

        for (int x = 0; x <= widthInTiles; x++) {
            for (int y = 0; y <= heightInTiles; y++) {

                intersections.Add(new Rectangle(

                    (target.X + x*(TILESIZE-1)) / TILESIZE,
                    (target.Y + y*TILESIZE) / TILESIZE,
                    TILESIZE,
                    TILESIZE

                ));

            }
        }

        return intersections;
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // TODO: Add your drawing code here
        _spriteBatch.Begin(samplerState: SamplerState.PointClamp);

        int num_tiles_per_row = 8;
        int pixel_tilesize = 8;

        // drawing the layers (same for every layer)

        foreach (var item in mg) {
            // create the destination rect from the key
            Rectangle drect = new(
                (int)item.Key.X * TILESIZE + (int)camera.X,
                (int)item.Key.Y * TILESIZE + (int)camera.Y,
                TILESIZE,
                TILESIZE
            );

            // get the src rect (the part of the image drawn) from the value
            int x = item.Value % num_tiles_per_row;
            int y = item.Value / num_tiles_per_row;

            Rectangle src = new(
                x * pixel_tilesize,
                y * pixel_tilesize,
                pixel_tilesize,
                pixel_tilesize
            );

            _spriteBatch.Draw(textureAtlas, drect, src, Color.White);
        }

        foreach (var item in fg) {
            Rectangle drect = new(
                (int)item.Key.X * TILESIZE + (int)camera.X,
                (int)item.Key.Y * TILESIZE + (int)camera.Y,
                TILESIZE,
                TILESIZE
            );

            int x = item.Value % num_tiles_per_row;
            int y = item.Value / num_tiles_per_row;

            Rectangle src = new(
                x * pixel_tilesize,
                y * pixel_tilesize,
                pixel_tilesize,
                pixel_tilesize
            );

            _spriteBatch.Draw(textureAtlas, drect, src, Color.White);
        }

        foreach (var item in collisions) {
            Rectangle drect = new(
                (int)item.Key.X * TILESIZE + (int)camera.X,
                (int)item.Key.Y * TILESIZE + (int)camera.Y,
                TILESIZE,
                TILESIZE
            );

            int x = item.Value % num_tiles_per_row;
            int y = item.Value / num_tiles_per_row;

            Rectangle src = new(
                x * pixel_tilesize,
                y * pixel_tilesize,
                pixel_tilesize,
                pixel_tilesize
            );

            _spriteBatch.Draw(hitboxTexture, drect, src, Color.White);
        }

        foreach (var rect in intersections) {

            DrawRectHollow(
                _spriteBatch,
                new Rectangle(
                    rect.X * TILESIZE,
                    rect.Y * TILESIZE,
                    TILESIZE,
                    TILESIZE
                ),
                4
            );

        }

        player.Draw(_spriteBatch);

        DrawRectHollow(_spriteBatch, player.rect, 4);

        _spriteBatch.End();

        base.Draw(gameTime);
    }

    public void DrawRectHollow(SpriteBatch spriteBatch, Rectangle rect, int thickness) {
        spriteBatch.Draw(
            rectangleTexture,
            new Rectangle(
                rect.X,
                rect.Y,
                rect.Width,
                thickness
            ),
            Color.White
        );
        spriteBatch.Draw(
            rectangleTexture,
            new Rectangle(
                rect.X,
                rect.Bottom - thickness,
                rect.Width,
                thickness
            ),
            Color.White
        );
        spriteBatch.Draw(
            rectangleTexture,
            new Rectangle(
                rect.X,
                rect.Y,
                thickness,
                rect.Height
            ),
            Color.White
        );
        spriteBatch.Draw(
            rectangleTexture,
            new Rectangle(
                rect.Right - thickness,
                rect.Y,
                thickness,
                rect.Height
            ),
            Color.White
        );
    }
}
